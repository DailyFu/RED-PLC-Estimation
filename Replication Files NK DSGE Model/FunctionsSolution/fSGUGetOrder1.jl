#=
==========================================================================
% This functions obtains the numerical values of the derivatives of the
% equilibrium conditions needed to compute the first order approximation
% for the New Keynesian model in ACHSV.
%
% This function was created manually after calling computing the fx fy fxp fyp
% matrices using the SGU toolbox in Matlab.
%
% Written by: Pablo Cuba-Borda, Federal Reserve Board
% Created: November 17, 2017. Washington D.C.
% Modified: December 22, 2020.
==========================================================================
=#

function fSGUGetOrder1(params_in)

# Map parameters
phi    = params_in["phi"];
nu     = params_in["nu"];
tau    = params_in["tau"];
eta    = params_in["eta"];
psi1   = params_in["psi1"];
psi2   = params_in["psi2"];
bet    = params_in["beta"];
pist   = params_in["pi_ss"];
pibar  = params_in["pibar"];
gstar  = params_in["gstar"];
rhoz   = params_in["rho_z"];
rhog   = params_in["rho_g"];
rhor   = params_in["rho_r"];
rhod   = params_in["rho_d"];
rhom   = 0.0;
sigz   = params_in["sig_z"];
sigg   = params_in["sig_g"];
sigd   = params_in["sig_d"];
sigm   = params_in["sig_r"];
chi_h  = params_in["chi_h"];
cy     = params_in["cy"];
gst    = params_in["gstar"];
c_ss   = params_in["c_ss"];
y_ss   = params_in["y_ss"];
inveta = 1.0/eta;
# -------------------------
#  STEADY STATES IN LEVELS
# -------------------------
p1    = 0.0;
y1    = 0.0;
c1    = 0.0;
z1    = 0.0;
g1    = 0.0;
d1    = 0.0;
m1    = 0.0;

# ----------------------------------------------
#  MAP STEADY STATE VALUES TO TIME t+1 VARIABLES
# ----------------------------------------------
p2 = p1;
y2 = y1;
c2 = c1;
z2 = z1;
g2 = g1;
d2 = d1;
m2 = m1;

# ----------------------------------------------
#  MAP STEADY STATE VALUES TO TIME t-1 VARIABLES
# ----------------------------------------------
ylag1 = 0.0;
ylag2 = y1;
Rlag1 = 0.0;
Rlag2 = Rlag1;

# ----------------------------------------------
# Copy nfx nfxp nfy nfyp nf nETASHOCK from the output
# generated by anal_deriv_print2f.m
# ----------------------------------------------

# Below commented out expressions come from MATLAB as explained followed by
# more Julia-friendly expressions.

# % File name: acs_model_num_eval.m
# % File generated by anal_deriv_print2f.m Date: 04-Jan-2021

# nfx=[[0]
#  [0]
#  [-rhor]
#  [0]
#  [0]
#  [0]
#  [0]
#  [0]
#  [0]
#  [0]
#  [-psi2*(rhor - 1)]
#  [0]
#  [0]
#  [0]
#  [0]
#  [0]
#  [0]
#  [0]
#  [psi2*(rhor - 1)]
#  [0]
#  [-rhoz]
#  [0]
#  [0]
#  [0]
#  [tau*exp(Rlag2 - d1 + d2 - p2 - z2 - tau*(g1 - y1) + tau*(g2 - y2))]
#  [c_ss^tau*chi_h*tau*y_ss^inveta*exp(inveta*y1 - tau*(g1 - y1)) - bet*nu*phi*pist*tau*exp(d2 - d1 + p2 - y1 + y2 - tau*(g1 - y1) + tau*(g2 - y2))*(pibar - pist*exp(p2))]
#  [0]
#  [0]
#  [0]
#  [-rhog]
#  [0]
#  [0]
#  [exp(Rlag2 - d1 + d2 - p2 - z2 - tau*(g1 - y1) + tau*(g2 - y2))]
#  [-bet*nu*phi*pist*exp(d2 - d1 + p2 - y1 + y2 - tau*(g1 - y1) + tau*(g2 - y2))*(pibar - pist*exp(p2))]
#  [0]
#  [0]
#  [0]
#  [0]
#  [-rhod]
#  [0]
#  [0]
#  [0]
#  [-1]
#  [0]
#  [0]
#  [0]
#  [0]
#  [-rhom]];
#
#  nfx=reshape(nfx,8,6);

nfx=zeros(Float64,8,6)
nfx[3,1]=-rhor
nfx[3,2]=-psi2*(rhor - 1.0)
nfx[3,3]=psi2*(rhor - 1.0)
nfx[5,3]=-rhoz
nfx[1,4]=tau*exp(Rlag2 - d1 + d2 - p2 - z2 - tau*(g1 - y1) + tau*(g2 - y2))
nfx[2,4]=c_ss^tau*chi_h*tau*y_ss^inveta*exp(inveta*y1 - tau*(g1 - y1)) - bet*nu*phi*pist*tau*exp(d2 - d1 + p2 - y1 + y2 - tau*(g1 - y1) + tau*(g2 - y2))*(pibar - pist*exp(p2))
nfx[6,4]=-rhog
nfx[1,5]=exp(Rlag2 - d1 + d2 - p2 - z2 - tau*(g1 - y1) + tau*(g2 - y2))
nfx[2,5]=-bet*nu*phi*pist*exp(d2 - d1 + p2 - y1 + y2 - tau*(g1 - y1) + tau*(g2 - y2))*(pibar - pist*exp(p2))
nfx[7,5]=-rhod
nfx[3,6]=-1.0
nfx[8,6]=-rhom

# nfxp=[[-exp(Rlag2 - d1 + d2 - p2 - z2 - tau*(g1 - y1) + tau*(g2 - y2))]
#  [0]
#  [1]
#  [0]
#  [0]
#  [0]
#  [0]
#  [0]
#  [0]
#  [0]
#  [0]
#  [1]
#  [0]
#  [0]
#  [0]
#  [0]
#  [exp(Rlag2 - d1 + d2 - p2 - z2 - tau*(g1 - y1) + tau*(g2 - y2))]
#  [0]
#  [0]
#  [0]
#  [1]
#  [0]
#  [0]
#  [0]
#  [-tau*exp(Rlag2 - d1 + d2 - p2 - z2 - tau*(g1 - y1) + tau*(g2 - y2))]
#  [bet*nu*phi*pist*tau*exp(d2 - d1 + p2 - y1 + y2 - tau*(g1 - y1) + tau*(g2 - y2))*(pibar - pist*exp(p2))]
#  [0]
#  [0]
#  [0]
#  [1]
#  [0]
#  [0]
#  [-exp(Rlag2 - d1 + d2 - p2 - z2 - tau*(g1 - y1) + tau*(g2 - y2))]
#  [bet*nu*phi*pist*exp(d2 - d1 + p2 - y1 + y2 - tau*(g1 - y1) + tau*(g2 - y2))*(pibar - pist*exp(p2))]
#  [0]
#  [0]
#  [0]
#  [0]
#  [1]
#  [0]
#  [0]
#  [0]
#  [0]
#  [0]
#  [0]
#  [0]
#  [0]
#  [1]];
#
# nfxp=reshape(nfxp,8,6);

nfxp=zeros(Float64,8,6)
nfxp[1,1]=-exp(Rlag2 - d1 + d2 - p2 - z2 - tau*(g1 - y1) + tau*(g2 - y2))
nfxp[3,1]=1.0
nfxp[4,2]=1.0
nfxp[1,3]=exp(Rlag2 - d1 + d2 - p2 - z2 - tau*(g1 - y1) + tau*(g2 - y2))
nfxp[5,3]=1.0
nfxp[1,4]=-tau*exp(Rlag2 - d1 + d2 - p2 - z2 - tau*(g1 - y1) + tau*(g2 - y2))
nfxp[2,4]=bet*nu*phi*pist*tau*exp(d2 - d1 + p2 - y1 + y2 - tau*(g1 - y1) + tau*(g2 - y2))*(pibar - pist*exp(p2))
nfxp[6,4]=1.0
nfxp[1,5]=-exp(Rlag2 - d1 + d2 - p2 - z2 - tau*(g1 - y1) + tau*(g2 - y2))
nfxp[2,5]=bet*nu*phi*pist*exp(d2 - d1 + p2 - y1 + y2 - tau*(g1 - y1) + tau*(g2 - y2))*(pibar - pist*exp(p2))
nfxp[7,5]=1.0
nfxp[8,6]=1.0

# nfy=[[0]
#  [nu*phi*pist^2*exp(2*p1) + phi*pist*exp(p1)*(pibar - pist*exp(p1)) - nu*phi*pist*exp(p1)*(pibar - pist*exp(p1))]
#  [psi1*(rhor - 1)]
#  [0]
#  [0]
#  [0]
#  [0]
#  [0]
#  [-tau*exp(Rlag2 - d1 + d2 - p2 - z2 - tau*(g1 - y1) + tau*(g2 - y2))]
#  [bet*nu*phi*pist*exp(d2 - d1 + p2 - y1 + y2 - tau*(g1 - y1) + tau*(g2 - y2))*(pibar - pist*exp(p2))*(tau - 1) - c_ss^tau*chi_h*y_ss^inveta*exp(inveta*y1 - tau*(g1 - y1))*(inveta + tau)]
# [psi2*(rhor - 1)]
#  [-1]
#  [0]
#  [0]
#  [0]
#  [0]];
#
# nfy=reshape(nfy,8,2);

nfy=zeros(Float64,8,2)
nfy[2,1]=nu*phi*pist^2*exp(2.0*p1) - nu*phi*pist*exp(p1)*(pibar - pist*exp(p1)) +  phi*pist*exp(p1)*(pibar - pist*exp(p1));
nfy[3,1]=psi1*(rhor - 1.0)
nfy[1,2]=-tau*exp(Rlag2 - d1 + d2 - p2 - z2 - tau*(g1 - y1) + tau*(g2 - y2))
nfy[2,2]=bet*nu*phi*pist*exp(d2 - d1 + p2 - y1 + y2 - tau*(g1 - y1) + tau*(g2 - y2))*(pibar - pist*exp(p2))*(tau - 1.0) - c_ss^tau*chi_h*y_ss^inveta*exp(inveta*y1 - tau*(g1 - y1))*(inveta + tau)
nfy[3,2]=psi2*(rhor - 1.0)
nfy[4,2]=-1.0


# nfyp=[[exp(Rlag2 - d1 + d2 - p2 - z2 - tau*(g1 - y1) + tau*(g2 - y2))]
#  [bet*nu*phi*pist*exp(d2 - d1 + p2 - y1 + y2 - tau*(g1 - y1) + tau*(g2 - y2))*(pibar - pist*exp(p2)) - bet*nu*phi*pist^2*exp(d2 - d1 + p2 - y1 + y2 - tau*(g1 - y1) + tau*(g2 - y2))*exp(p2)]
#  [0]
#  [0]
#  [0]
#  [0]
#  [0]
#  [0]
#  [tau*exp(Rlag2 - d1 + d2 - p2 - z2 - tau*(g1 - y1) + tau*(g2 - y2))]
#  [-bet*nu*phi*pist*exp(d2 - d1 + p2 - y1 + y2 - tau*(g1 - y1) + tau*(g2 - y2))*(pibar - pist*exp(p2))*(tau - 1)]
#  [0]
#  [0]
#  [0]
#  [0]
#  [0]
#  [0]];
#
#  nfyp=reshape(nfyp,8,2);

nfyp=zeros(Float64,8,2)
nfyp[1,1]=exp(Rlag2 - d1 + d2 - p2 - z2 - tau*(g1 - y1) + tau*(g2 - y2))
nfyp[2,1]=bet*nu*phi*pist*exp(d2 - d1 + p2 - y1 + y2 - tau*(g1 - y1) + tau*(g2 - y2))*(pibar - pist*exp(p2)) - bet*nu*phi*pist^2*exp(d2 - d1 + p2 - y1 + y2 - tau*(g1 - y1) + tau*(g2 - y2))*exp(p2)
nfyp[1,2]=tau*exp(Rlag2 - d1 + d2 - p2 - z2 - tau*(g1 - y1) + tau*(g2 - y2))
nfyp[2,2]=-bet*nu*phi*pist*exp(d2 - d1 + p2 - y1 + y2 - tau*(g1 - y1) + tau*(g2 - y2))*(pibar - pist*exp(p2))*(tau - 1.0)

# This is not used

# nf=[[1 - exp(Rlag2 - d1 + d2 - p2 - z2 - tau*(g1 - y1) + tau*(g2 - y2))]
#  [bet*nu*phi*pist*exp(d2 - d1 + p2 - y1 + y2 - tau*(g1 - y1) + tau*(g2 - y2))*(pibar - pist*exp(p2)) - (phi*(pibar - pist*exp(p1))^2)/2 - c_ss^tau*chi_h*y_ss^inveta*exp(inveta*y1 - tau*(g1 - y1)) - nu*phi*pist*exp(p1)*(pibar - pist*exp(p1)) - nu + 1]
#  [Rlag2 - m1 - Rlag1*rhor + p1*psi1*(rhor - 1) + psi2*(rhor - 1)*(y1 - ylag1 + z1)]
#  [ylag2 - y1]
#  [z2 - rhoz*z1]
#  [g2 - g1*rhog]
#  [d2 - d1*rhod]
#  [m2 - m1*rhom]];
#
# nf=reshape(nf,8 ,1);

 # nETASHOCK=[[sigz]
 #  [0]
 #  [0]
 #  [0]
 #  [0]
 #  [sigg]
 #  [0]
 #  [0]
 #  [0]
 #  [0]
 #  [sigd]
 #  [0]
 #  [0]
 #  [0]
 #  [0]
 #  [sigm]];
#
 # nETASHOCK  = reshape(nETASHOCK,4,4)

nETASHOCK=zeros(Float64,4,4)
nETASHOCK[1,1]=sigz
nETASHOCK[2,2]=sigg
nETASHOCK[3,3]=sigd
nETASHOCK[4,4]=sigm

vcv = nETASHOCK^2


return nfx, nfxp, nfy, nfyp, vcv

end
